{"name":"Django RADIUS","tagline":"A RADIUS authentication backend for Django","body":"django-radius\r\n=============\r\n\r\ndjango-radius enables you to authenticate your Django users against one or many\r\nRADIUS servers easily.\r\n\r\nRADIUS Authentication Backend\r\n-----------------------------\r\n\r\nThe standard RADIUS backend (`radiusauth.backends.RADIUSBackend`) allows you to\r\nauthenticate against a single RADIUS server easily, and is used by adding it to\r\nthe `AUTHENTICATION_BACKENDS` parameter in your project's settings file:\r\n\r\n```python\r\nAUTHENTICATION_BACKENDS = (\r\n    'radiusauth.backends.RADIUSBackend',\r\n    'django.contrib.auth.backends.ModelBackend',\r\n)\r\n```\r\n\r\nThis will first attempt to authenticate a user with the traditional Django\r\nmodel-based system, and failing that, the RADIUS server.\r\n\r\nThe RADIUS server is specified in the settings file also, with the following\r\nparameters:\r\n\r\n```python\r\nRADIUS_SERVER = 'localhost'\r\nRADIUS_PORT = 1812\r\nRADIUS_SECRET = 'S3kr3T'\r\n```\r\n\r\nWhen a user is successfully authenticated via the RADIUS backend, a `User`\r\nobject is created in Django's built-in auth application with the same username.\r\nThis user's password is set to the password which they logged into the RADIUS\r\nserver with, so that they will be able to login with their \"cached\"\r\ncredentials, even if the RADIUS server is down. All activity within the Django\r\nproject can then be linked to this `User` object via foreign keys etc.\r\n\r\nThis is why the `RADIUSBackend` appears *before* the Django `ModelBackend` - so\r\nthat when users change their passwords on the RADIUS system, they are still\r\nable to login to the Django application (and their cached credentials are\r\nupdated).\r\n\r\nThis is the quickest and easiest way to enable simple, single-server RADIUS\r\nauthentication for your Django project.\r\n\r\nRealm-Based RADIUS Authentication for Multiple RADIUS Servers\r\n-------------------------------------------------------------\r\n\r\nFor a more advanced system, you might want to authenticate users with different\r\nRADIUS servers, depending upon some arbitrary condition.\r\n\r\nThis might seem contrived, but the idea is to separate \"realms\" of users by,\r\nfor example, the URL they access your project with. People browsing to\r\nhttp://client1.myproject.com might need to authenticate against one RADIUS\r\nserver, whilst people using http://client2.myproject.com might need to\r\nauthenticate against another.\r\n\r\nThe realm-based RADIUS authentication backend\r\n(`radiusauth.backends.RADIUSRealmBackend`) expects to be provided with an extra\r\nargument when authenticating a user: the realm in which they belong.\r\nThe realm is used to determine which RADIUS server to contact when verifying\r\nthe user's credentials - though this logic is up to the developer to implement\r\nby overriding the `get_server` method.\r\n\r\nAs with the standard RADIUS backend, a `User` object is created in the Django\r\nauth application when a user successfully logs into the system. With the\r\nrealm-based backend, however, the username is set to the string returned by the\r\n`construct_full_username` method, which is supplied with the username and the\r\nrealm. By default, this method returns a string in the format\r\n<username>@<realm> to avoid clashes in the Django user database. You should be\r\naware of this fact when displaying usernames in templates etc., as users might\r\nbe confused by a username which looks similar to an email address, but is\r\nclearly not.\r\n\r\n### Customised Functionality\r\n\r\nThe `get_server` method of the backend class is used to determine which RADIUS\r\nserver to authenticate against. This can be customised by extending the\r\n`RADIUSRealmBackend` class, and implementing this method. `get_server` takes\r\none argument: the realm which is passed to the `authenticate` method.\r\n\r\nBy default, the `RADIUSRealmBackend` simply returns the RADIUS server details\r\nspecified in the project's settings file.\r\n\r\nTo use your customised version of the `RADIUSRealmBackend`, just specify it in\r\nyour settings file as above:\r\n\r\n```python\r\nAUTHENTICATION_BACKENDS = (\r\n    'myproject.users.MyRADIUSBackend',\r\n    'django.contrib.auth.backends.ModelBackend',\r\n)\r\n```\r\n\r\n### Example Project\r\n\r\nHere is an example of how a project might be constructed to authenticate to two\r\ndifferent RADIUS servers.\r\n\r\n`myproject/users/backends.py`\r\n\r\n```python\r\nfrom radiusauth.backends import RADIUSRealmBackend\r\n\r\nRADIUS_SERVERS = {\r\n    'client1.myproject.com': ('radius.client1.com', 1812, 'S3kr3T'),\r\n    'client2.myproject.com': ('radius.client2.com', 1812, 'p@55w0Rd'),\r\n}\r\n\r\nclass MyRADIUSBackend(RADIUSRealmBackend):\r\n    def get_server(self, realm):\r\n        if realm in RADIUS_SERVERS:\r\n            return RADIUS_SERVERS[realm]\r\n        return None\r\n```\r\n\r\n`myproject/users/forms.py`\r\n\r\n```python\r\nfrom django import forms\r\n\r\nfrom django.contrib.auth import authenticate\r\nfrom django.contrib.auth.forms import AuthenticationForm\r\n\r\nclass RADIUSAuthenticationForm(AuthenticationForm):\r\n    def __init__(self, realm, request, *args, **kwargs):\r\n        super(UserAuthenticationForm, self).__init__(request, *args, **kwargs)\r\n        self.realm = realm\r\n\r\n    def clean(self):\r\n        username = self.cleaned_data.get('username')\r\n        password = self.cleaned_data.get('password')\r\n\r\n        if self.realm and username and password:\r\n            self.user_cache = authenticate(realm=self.realm,\r\n                                           username=username,\r\n                                           password=password)\r\n            if self.user_cache is None:\r\n                raise forms.ValidationError(\r\n                    'Please enter a correct username and password. '\r\n                    'Note that both fields are case-sensitive.')\r\n            elif not self.user_cache.is_active:\r\n                raise forms.ValidationError('This account is inactive.')\r\n        self.check_for_test_cookie()\r\n        return self.cleaned_data\r\n\r\n    def get_user(self):\r\n        return self.user_cache\r\n```\r\n\r\n`myproject/users/urls.py`\r\n\r\n```python\r\nfrom django.conf.urls.defaults import patterns, url\r\n\r\nfrom myproject.users.forms import RADIUSAuthenticationForm\r\n\r\nurlpatterns = patterns('django.contrib.auth.views',\r\n\r\n    url(r'^login/$', 'login',\r\n        {'authentication_form': RADIUSAuthenticationForm},\r\n        name='radius_login'),\r\n\r\n)\r\n```\r\n\r\n`myproject/settings.py`\r\n\r\n```python\r\n...\r\nAUTHENTICATION_BACKENDS = (\r\n    'myproject.users.backends.MyRADIUSBackend',\r\n    'django.contrib.auth.backends.ModelBackend',\r\n)\r\n...\r\n```\r\n\r\nThe custom authentication form above is then instantiated with a `realm`\r\nargument (determined by some other means) which is then passed to Django's\r\n`authenticate` method. The `RADIUSRealmBackend` can then use this value to\r\ndetermine which RADIUS server to use when validating the user's credentials.\r\n\r\nAdditional Attributes\r\n---------------------\r\n\r\nThe RADIUS authentication packet contains the following attributes by default:\r\n\r\n* `User-Name` (the user's username)\r\n* `User-Password` (the user's password)\r\n* `NAS-Identifier` (`django-radius`)\r\n\r\nTo set additional attributes, use the `RADIUS_ATTRIBUTES` setting:\r\n\r\n```python\r\n...\r\nRADIUS_ATTRIBUTES = {\r\n    \"NAS-IP-Address\": \"192.168.1.10\",\r\n    \"NAS-Port\": 0,\r\n    \"Service-Type\": \"Login-User\",\r\n}\r\n...\r\n```\r\n\r\nRADIUS attribute types 1-39 are supported. See the [Radius Types][types]\r\nIANA page for details.\r\n\r\n[types]: http://www.iana.org/assignments/radius-types/radius-types.xhtml\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}